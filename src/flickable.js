// Generated by CoffeeScript 1.6.2
(function(global, document, helper) {
  var Flickable;

  Flickable = (function() {
    function Flickable(element, opts) {
      var _this = this;

      if (opts == null) {
        opts = {};
      }
      this.el = element;
      this.opts = opts;
      this.helper = helper;
      this.browser = this.helper.checkBrowser();
      this.support = this.helper.checkSupport();
      this.events = this.helper.checkTouchEvents();
      if (typeof element === "string") {
        this.el = document.querySelector(element);
      } else if (!this.el) {
        throw new Error("Element Not Found");
      }
      this.opts.use3d = this.opts.disable3d ? false : this.support.transform3d;
      this.opts.useJsAnimate = false;
      this.opts.disableTouch = this.opts.disableTouch || false;
      this.opts.disable3d = this.opts.disable3d || false;
      this.opts.autoPlay = this.opts.autoPlay || false;
      this.opts.interval = this.opts.interval || 6600;
      this.opts.loop = this.opts.loop || (this.opts.autoPlay ? true : false);
      this.opts.transition = this.opts.transition || {};
      this.opts.transition = {
        timingFunction: this.opts.transition["timingFunction"] || "cubic-bezier(0.23, 1, 0.32, 1)",
        duration: (function() {
          return _this.opts.transition["duration"] || (_this.browser.isLegacy ? "200ms" : "330ms");
        })()
      };
      this.currentPoint = this.opts.currentPoint === void 0 && this.opts.loop ? 1 : this.opts.currentPoint || 0;
      this.maxPoint = this.currentX = this.maxX = 0;
      this.gestureStart = this.moveReady = this.scrolling = this.didCloneNode = false;
      this.startTime = this.timerId = this.basePageX = this.startPageX = this.startPageY = this.distance = null;
      if (this.support.cssAnimation) {
        this.helper.setStyle(this.el, {
          transitionProperty: this.helper.getCSSVal("transform"),
          transitionDuration: "0ms",
          transitionTimingFunction: this.opts.transition["timingFunction"],
          transform: this._getTranslate(0)
        });
      } else {
        this.helper.setStyle(this.el, {
          position: "relative",
          left: "0px"
        });
      }
      if (this.support.eventListener) {
        document.addEventListener("gesturestart", function() {
          return _this.gestureStart = true;
        }, false);
        document.addEventListener("gestureend", function() {
          return _this.gestureStart = false;
        }, false);
      }
      global.addEventListener("blur", function() {
        return _this._clearAutoPlay();
      }, false);
      global.addEventListener("focus", function() {
        return _this._startAutoPlay();
      }, false);
      this.el.addEventListener(this.events.start, this, false);
      if (this.opts.autoPlay) {
        this._startAutoPlay();
      }
      if (this.opts.loop) {
        this._cloneNode();
      }
      this.refresh();
    }

    Flickable.prototype.handleEvent = function(event) {
      switch (event.type) {
        case this.events.start:
          return this._touchStart(event);
        case this.events.move:
          return this._touchMove(event);
        case this.events.end:
          return this._touchEnd(event);
        case "click":
          return this._click(event);
      }
    };

    Flickable.prototype.refresh = function() {
      var getMaxPoint,
        _this = this;

      this._setTotalWidth();
      getMaxPoint = function() {
        var childNodes, i, itemLength, node, _i, _len;

        childNodes = _this.el.childNodes;
        itemLength = 0;
        for (i = _i = 0, _len = childNodes.length; _i < _len; i = ++_i) {
          node = childNodes[i];
          if (node.nodeType === 1) {
            itemLength++;
          }
        }
        if (itemLength > 0) {
          itemLength--;
        }
        return itemLength;
      };
      this.maxPoint = this.opts.maxPoint === void 0 ? getMaxPoint() : this.opts.maxPoint;
      this.distance = this.opts.distance === void 0 ? this.el.scrollWidth / (this.maxPoint + 1) : this.opts.distance;
      this.maxX = -this.distance * this.maxPoint;
      return this.moveToPoint();
    };

    Flickable.prototype.hasPrev = function() {
      return this.currentPoint > 0;
    };

    Flickable.prototype.hasNext = function() {
      return this.currentPoint < this.maxPoint;
    };

    Flickable.prototype.toPrev = function() {
      if (!this.hasPrev()) {
        return;
      }
      return this.moveToPoint(this.currentPoint - 1);
    };

    Flickable.prototype.toNext = function() {
      if (!this.hasNext()) {
        return;
      }
      return this.moveToPoint(this.currentPoint + 1);
    };

    Flickable.prototype.moveToPoint = function(point, duration) {
      var beforePoint;

      if (point == null) {
        point = this.currentPoint;
      }
      if (duration == null) {
        duration = this.opts.transition["duration"];
      }
      beforePoint = this.currentPoint;
      this.currentPoint = point < 0 ? 0 : point > this.maxPoint ? this.maxPoint : parseInt(point, 10);
      if (this.support.cssAnimation) {
        this.helper.setStyle(this.el, {
          transitionDuration: duration
        });
      } else {
        this.opts.useJsAnimate = true;
      }
      this._setX(-this.currentPoint * this.distance, duration);
      if (beforePoint !== this.currentPoint) {
        this.helper.triggerEvent(this.el, "flpointmove", true, false);
        if (this.opts.loop) {
          return this._loop();
        }
      }
    };

    Flickable.prototype._setX = function(x, duration) {
      if (duration == null) {
        duration = this.opts.transition["duration"];
      }
      this.currentX = x;
      if (this.support.cssAnimation && !this.browser.isLegacy) {
        return this.helper.setStyle(this.el, {
          transform: this._getTranslate(x)
        });
      } else if (this.opts.useJsAnimate) {
        return this._jsAnimate(x, duration);
      } else {
        return this.el.style.left = "" + x + "px";
      }
    };

    Flickable.prototype._touchStart = function(event) {
      if (this.opts.disableTouch || this.gestureStart) {
        return;
      }
      if (this.opts.loop) {
        if (this.currentPoint === this.maxPoint) {
          this.moveToPoint(1, 0);
        } else if (this.currentPoint === 0) {
          this.moveToPoint(this.maxPoint - 1, 0);
        }
      }
      this.el.addEventListener(this.events.move, this, false);
      document.addEventListener(this.events.end, this, false);
      if (!this.events.touch) {
        event.preventDefault();
      }
      if (this.support.cssAnimation) {
        this.helper.setStyle(this.el, {
          transitionDuration: "0ms"
        });
      } else {
        this.opts.useJsAnimate = false;
      }
      this.scrolling = true;
      this.moveReady = false;
      this.startPageX = this.helper.getPage(event, "pageX");
      this.startPageY = this.helper.getPage(event, "pageY");
      this.basePageX = this.startPageX;
      this.directionX = 0;
      this.startTime = event.timeStamp;
      return this.helper.triggerEvent(this.el, "fltouchstart", true, false);
    };

    Flickable.prototype._touchMove = function(event) {
      var deltaX, deltaY, distX, isPrevent, newX, pageX, pageY;

      if (this.opts.autoPlay) {
        this._clearAutoPlay();
      }
      if (!this.scrolling || this.gestureStart) {
        return;
      }
      pageX = this.helper.getPage(event, "pageX");
      pageY = this.helper.getPage(event, "pageY");
      if (this.moveReady) {
        event.preventDefault();
        event.stopPropagation();
        distX = pageX - this.basePageX;
        newX = this.currentX + distX;
        if (newX >= 0 || newX < this.maxX) {
          newX = Math.round(this.currentX + distX / 3);
        }
        this.directionX = distX === 0 ? this.directionX : distX > 0 ? -1 : 1;
        isPrevent = !this.helper.triggerEvent(this.el, "fltouchmove", true, true, {
          delta: distX,
          direction: this.directionX
        });
        if (isPrevent) {
          this._touchAfter({
            moved: false,
            originalPoint: this.currentPoint,
            newPoint: this.currentPoint,
            cancelled: true
          });
        } else {
          this._setX(newX);
        }
      } else {
        deltaX = Math.abs(pageX - this.startPageX);
        deltaY = Math.abs(pageY - this.startPageY);
        if (deltaX > 5) {
          event.preventDefault();
          event.stopPropagation();
          this.moveReady = true;
          this.el.addEventListener("click", this, true);
        } else if (deltaY > 5) {
          this.scrolling = false;
        }
      }
      this.basePageX = pageX;
      if (this.opts.autoPlay) {
        return this._startAutoPlay();
      }
    };

    Flickable.prototype._touchEnd = function(event) {
      var newPoint,
        _this = this;

      this.el.removeEventListener(this.events.move, this, false);
      document.removeEventListener(this.events.end, this, false);
      if (!this.scrolling) {
        return;
      }
      newPoint = (function() {
        var point;

        point = -_this.currentX / _this.distance;
        if (_this.directionX > 0) {
          return Math.ceil(point);
        } else if (_this.directionX < 0) {
          return Math.floor(point);
        } else {
          return Math.round(point);
        }
      })();
      if (newPoint < 0) {
        newPoint = 0;
      } else if (newPoint > this.maxPoint) {
        newPoint = this.maxPoint;
      }
      this._touchAfter({
        moved: newPoint !== this.currentPoint,
        originalPoint: this.currentPoint,
        newPoint: newPoint,
        cancelled: false
      });
      return this.moveToPoint(newPoint);
    };

    Flickable.prototype._touchAfter = function(params) {
      var _this = this;

      this.scrolling = false;
      this.moveReady = false;
      global.setTimeout(function() {
        return _this.el.removeEventListener("click", _this, true);
      }, 200);
      return this.helper.triggerEvent(this.el, "fltouchend", true, false, params);
    };

    Flickable.prototype._click = function(event) {
      event.stopPropagation();
      return event.preventDefault();
    };

    Flickable.prototype._getTranslate = function(x) {
      if (this.opts.use3d) {
        return "translate3d(" + x + "px, 0, 0)";
      } else {
        return "translate(" + x + "px, 0)";
      }
    };

    Flickable.prototype._cloneNode = function() {
      var childNodes, firstItem, itemAry, lastItem, node, _i, _len;

      childNodes = this.el.childNodes;
      itemAry = [];
      if (!this.opts.loop || this.didCloneNode) {
        return;
      }
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        node = childNodes[_i];
        if (node.nodeType === 1) {
          itemAry.push(node);
        }
      }
      firstItem = itemAry.shift();
      lastItem = itemAry.pop();
      this.el.insertBefore(lastItem.cloneNode(true), firstItem);
      this.el.appendChild(firstItem.cloneNode(true));
      return this.didCloneNode = true;
    };

    Flickable.prototype._startAutoPlay = function() {
      var interval, toNextFn,
        _this = this;

      if (!this.opts.autoPlay) {
        return;
      }
      toNextFn = function() {
        return _this.toNext();
      };
      interval = this.opts.interval;
      return (function() {
        return _this.timerId = global.setInterval(toNextFn, interval);
      })();
    };

    Flickable.prototype._clearAutoPlay = function() {
      return global.clearInterval(this.timerId);
    };

    Flickable.prototype._setTotalWidth = function() {
      var childNodes, itemAry, itemWidth, node, totalWidth, _i, _len;

      childNodes = this.el.childNodes;
      itemAry = childNodes.length !== 0 ? [] : [this.el];
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        node = childNodes[_i];
        if (node.nodeType === 1) {
          itemAry.push(node);
        }
      }
      itemWidth = this.helper.getWidth(itemAry[0]);
      totalWidth = itemWidth * itemAry.length;
      return this.el.style.width = "" + totalWidth + "px";
    };

    Flickable.prototype._loop = function() {
      var clearTime, lastPoint, smartLoop, timerId, transitionEndEventName,
        _this = this;

      lastPoint = this.maxPoint - 1;
      clearTime = this.opts.interval / 2;
      smartLoop = function() {
        if (_this.currentPoint === _this.maxPoint) {
          return _this.moveToPoint(1, 0);
        } else if (_this.currentPoint === 0) {
          return _this.moveToPoint(lastPoint, 0);
        }
      };
      transitionEndEventName = this.helper.getTransitionEndEventName();
      if (transitionEndEventName !== void 0) {
        this.el.addEventListener(transitionEndEventName, smartLoop, false);
        return global.setTimeout(function() {
          return _this.el.removeEventListener(transitionEndEventName, smartLoop, false);
        }, clearTime);
      } else {
        timerId = smartLoop;
        return global.clearTimeout(function() {
          return smartLoop();
        }, clearTime);
      }
    };

    Flickable.prototype._jsAnimate = function(x, duration) {
      var begin, easing, from, timer, to;

      if (duration == null) {
        duration = this.opts.transition["duration"];
      }
      begin = +new Date();
      from = parseInt(this.el.style.left, 10);
      to = x;
      duration = parseInt(duration, 10);
      easing = function(time, duration) {
        return -(time /= duration) * (time - 2);
      };
      return timer = global.setInterval(function() {
        var now, pos, time;

        time = new Date() - begin;
        if (time > duration) {
          global.clearInterval(timer);
          now = to;
        } else {
          pos = easing(time, duration);
          now = pos * (to - from) + from;
        }
        return this.el.style.left = "" + now + "px";
      }, 10);
    };

    Flickable.prototype.destroy = function() {
      return this.el.removeEventListener(this.events.start, this, false);
    };

    return Flickable;

  })();
  return global.Flickable = Flickable;
})(this, this.document, new Flickable.Helper());
