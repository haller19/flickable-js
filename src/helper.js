// Generated by CoffeeScript 1.6.2
(function(global, document) {
  var Helper;

  Helper = (function() {
    function Helper() {
      this.div = document.createElement("div");
      this.prefixes = ["webkit", "moz", "o", "ms"];
      this.saveProp = {};
    }

    Helper.prototype.getPage = function(event, page) {
      if (event.changedTouches) {
        return event.changedTouches[0][page];
      } else {
        return event[page];
      }
    };

    Helper.prototype.hasProp = function(props) {
      var prop, _i, _len;

      if (props instanceof Array) {
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          prop = props[_i];
          if (this.div.style[prop] !== void 0) {
            return true;
          }
        }
        return false;
      } else if (typeof props === "string") {
        if (this.div.style[prop] !== void 0) {
          return true;
        } else {
          return false;
        }
      } else {
        throw new TypeError("Must be a Array or String");
      }
    };

    Helper.prototype.setStyle = function(element, styles) {
      var hasSaveProp, prop, style, _results, _setAttr,
        _this = this;

      style = element.style;
      hasSaveProp = this.saveProp[prop];
      _setAttr = function(style, prop, val) {
        var prefix, _i, _len, _prop, _ref;

        if (hasSaveProp) {
          return style[hasSaveProp] = val;
        } else if (style[prop] !== void 0) {
          _this.saveProp[prop] = prop;
          return style[prop] = val;
        } else {
          _ref = _this.prefixes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            prefix = _ref[_i];
            _prop = _this.ucFirst(prefix) + _this.ucFirst(prop);
            if (style[_prop] !== void 0) {
              _this.saveProp[prop] = _prop;
              style[_prop] = val;
              return true;
            }
          }
          return false;
        }
      };
      _results = [];
      for (prop in styles) {
        _results.push(_setAttr(style, prop, styles[prop]));
      }
      return _results;
    };

    Helper.prototype.getCSSVal = function(prop) {
      var prefix, ret, _i, _len, _prop, _ref;

      if (typeof prop !== "string") {
        throw new TypeError("Must be a String");
      }
      if (this.div.style[prop] !== void 0) {
        return prop;
      } else {
        _ref = this.prefixes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prefix = _ref[_i];
          _prop = this.ucFirst(prefix) + this.ucFirst(prop);
          if (this.div.style[_prop] !== void 0) {
            ret = "-" + prefix + "-" + prop;
          }
        }
        return ret;
      }
    };

    Helper.prototype.ucFirst = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Must be a String");
      }
      return str.charAt(0).toUpperCase() + str.substr(1);
    };

    Helper.prototype.triggerEvent = function(element, type, bubbles, cancelable, data) {
      var d, event;

      if (typeof element !== "object") {
        throw new Error("Must be a Element");
      }
      event = document.createEvent("Event");
      event.initEvent(type, bubbles, cancelable);
      if (data) {
        for (d in data) {
          event[d] = data[d];
        }
      }
      return element.dispatchEvent(event);
    };

    Helper.prototype.checkBrowser = function() {
      var android, browserName, browserVersion, ios, ua;

      ua = global.navigator.userAgent.toLowerCase();
      ios = ua.match(/(?:iphone\sos|ip[oa]d.*os)\s([\d_]+)/);
      android = ua.match(/(android)\s+([\d.]+)/);
      browserName = !!ios ? "ios" : !!android ? "android" : "pc";
      browserVersion = (function() {
        if (!ios && !android) {
          return null;
        }
        return parseFloat((ios || android).pop().split(/\D/).join("."), 10);
      })();
      return {
        name: browserName,
        version: browserVersion,
        isLegacy: !!android && browserVersion < 3
      };
    };

    Helper.prototype.checkSupport = function() {
      var hasTransform, hasTransform3d, hasTransition;

      hasTransform3d = this.hasProp(["perspectiveProperty", "WebkitPerspective", "MozPerspective", "msPerspective", "OPerspective"]);
      hasTransform = this.hasProp(["transformProperty", "WebkitTransform", "MozTransform", "msTransform", "OTransform"]);
      hasTransition = this.hasProp(["transitionProperty", "WebkitTransitionProperty", "MozTransitionProperty", "msTransitionProperty", "OTransitionProperty"]);
      return {
        touch: "ontouchstart" in global,
        eventListener: "addEventListener" in global,
        transform3d: hasTransform3d,
        transform: hasTransform,
        transition: hasTransition,
        cssAnimation: hasTransform3d || hasTransform && hasTransition ? true : false
      };
    };

    Helper.prototype.checkTouchEvents = function() {
      var hasTouch;

      hasTouch = this.checkSupport.touch;
      return {
        start: hasTouch ? "touchstart" : "mousedown",
        move: hasTouch ? "touchmove" : "mousemove",
        end: hasTouch ? "touchend" : "mouseup"
      };
    };

    Helper.prototype.getWidth = function(element) {
      var border, boxSizingVal, css, hasBoxSizing, padding, styleParser, width;

      if (element === void 0) {
        throw new Error("Element Not Found");
      }
      css = global.getComputedStyle(element);
      boxSizingVal = void 0;
      hasBoxSizing = (function() {
        var prop, properties, _i, _len;

        properties = ["-webkit-box-sizing", "-moz-box-sizing", "-o-box-sizing", "-ms-box-sizing", "box-sizing"];
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          if (element.style[prop] !== void 0) {
            boxSizingVal = element.style[prop];
            return true;
          }
        }
        return false;
      })();
      if (!hasBoxSizing || boxSizingVal === "content-box") {
        styleParser = function(props) {
          var i, prop, total, value, _i, _len;

          value = [];
          total = 0;
          for (i = _i = 0, _len = props.length; _i < _len; i = ++_i) {
            prop = props[i];
            if (css[prop]) {
              value[i] = parseFloat(css[props[0]].match(/\d+/), 10);
              total += value[i];
            }
          }
          return total;
        };
        border = styleParser(["border-right-width", "border-left-width"]);
        padding = styleParser(["padding-right", "padding-left"]);
        return width = element.scrollWidth + border + padding;
      } else if (element.scrollWidth === 0) {
        width = parseFloat(element.style.width.match(/\d+/), 10);
        if (!element.style.boxSizing || !element.style.webkitBoxSizing) {
          if (element.style.paddingRight) {
            width += parseFloat(element.style.paddingRight.match(/\d+/), 10);
          }
          if (element.style.paddingLeft) {
            width += parseFloat(element.style.paddingLeft.match(/\d+/), 10);
          }
        }
        return width;
      } else {
        return width = element.scrollWidth;
      }
    };

    Helper.prototype.getTranslate = function(use3d, x, y, z) {
      if (use3d == null) {
        use3d = true;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      if (this.opts.use3d) {
        return "translate3d(" + x + "px, 0, 0)";
      } else {
        return "translate(" + x + "px, 0)";
      }
    };

    Helper.prototype.getTransitionEndEventName = function() {
      var browser, match, transitionEndName, ua, version;

      ua = global.navigator.userAgent.toLowerCase();
      match = /(webkit)[ \/]([\w.]+)/.exec(ua) || /(firefox)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || [];
      browser = match[1];
      version = parseFloat(match[2], 10);
      if (browser === "msie" && version >= 10) {
        browser = "modernIE";
      }
      switch (browser) {
        case "webkit":
          return transitionEndName = "webkitTransitionEnd";
        case "opera":
          return transitionEndName = "oTransitionEnd";
        case "firefox":
        case "modernIE":
          return transitionEndName = "transitionend";
        default:
          return transitionEndName = void 0;
      }
    };

    return Helper;

  })();
  return global.Flickable.Helper = Helper;
})(this, this.document);
